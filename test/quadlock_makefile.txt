# Makefile pour Quadlock Encrypt
# Usage: make [target]

PYTHON = python3
VENV = quadlock_env
VENV_BIN = $(VENV)/bin
PIP = $(VENV_BIN)/pip
PYTHON_VENV = $(VENV_BIN)/python

.PHONY: help install test clean setup dev lint format security audit package docs

# Cible par défaut
help:
	@echo "🔐 Quadlock Encrypt - Makefile"
	@echo "=============================="
	@echo ""
	@echo "Cibles disponibles:"
	@echo "  install    - Installation complète avec dépendances"
	@echo "  setup      - Configuration initiale (première utilisation)"
	@echo "  test       - Exécution des tests complets"
	@echo "  dev        - Installation pour développement"
	@echo "  clean      - Nettoyage des fichiers temporaires"
	@echo "  lint       - Vérification du code (pylint, flake8)"
	@echo "  format     - Formatage automatique du code (black)"
	@echo "  security   - Audit de sécurité (bandit)"
	@echo "  audit      - Audit des dépendances (pip-audit)"
	@echo "  package    - Création d'un package de distribution"
	@echo "  docs       - Génération de la documentation"
	@echo "  benchmark  - Tests de performance"
	@echo ""
	@echo "Exemples:"
	@echo "  make install    # Installation complète"
	@echo "  make test      # Tests rapides"
	@echo "  make clean     # Nettoyage"

# Installation complète
install: $(VENV)/pyvenv.cfg
	@echo "📦 Installation des dépendances..."
	$(PIP) install --upgrade pip
	$(PIP) install -r requirements.txt
	@chmod +x *.sh
	@echo "✅ Installation terminée!"

# Création de l'environnement virtuel
$(VENV)/pyvenv.cfg:
	@echo "🏗️  Création de l'environnement virtuel..."
	$(PYTHON) -m venv $(VENV)

# Configuration initiale
setup: install
	@echo "⚙️  Configuration initiale..."
	$(PYTHON_VENV) quadlock_encrypt.py config --create
	@echo "🧪 Exécution du test initial..."
	@./test_quadlock.sh
	@echo "✅ Configuration terminée!"

# Tests complets
test:
	@echo "🧪 Exécution des tests..."
	@./test_quadlock.sh
	@echo "🔍 Test d'intégrité..."
	@./verify_integrity.sh
	@echo "📊 Tests de performance basiques..."
	@$(PYTHON_VENV) -c "
import time
import secrets
from quadlock_encrypt import QuadlockApp
app = QuadlockApp()
data = secrets.token_bytes(1024*1024)  # 1MB
with open('test_perf.bin', 'wb') as f:
    f.write(data)
start = time.time()
app.encrypt_file('test_perf.bin', 'testpassword123')
encrypt_time = time.time() - start
print(f'⏱️  Chiffrement 1MB: {encrypt_time:.2f}s')
import os
os.remove('test_perf.bin')
if os.path.exists('test_perf.bin.qlk'):
    os.remove('test_perf.bin.qlk')
if os.path.exists('test_perf.bin.shares'):
    os.remove('test_perf.bin.shares')
"

# Installation pour développement
dev: install
	$(PIP) install pylint flake8 black bandit pip-audit pytest coverage
	@echo "🛠️  Environnement de développement prêt!"

# Vérification du code
lint:
	@echo "🔍 Analyse statique du code..."
	$(VENV_BIN)/pylint quadlock_encrypt.py --disable=C0103,R0903,W0613 || true
	$(VENV_BIN)/flake8 quadlock_encrypt.py --max-line-length=100 --ignore=E203,W503 || true
	@echo "✅ Analyse terminée!"

# Formatage du code
format:
	@echo "🎨 Formatage du code..."
	$(VENV_BIN)/black quadlock_encrypt.py --line-length=100
	@echo "✅ Formatage terminé!"

# Audit de sécurité
security:
	@echo "🔒 Audit de sécurité du code..."
	$(VENV_BIN)/bandit -r . -f json -o security_report.json || true
	$(VENV_BIN)/bandit -r . || true
	@echo "✅ Audit de sécurité terminé!"

# Audit des dépendances
audit:
	@echo "🔍 Audit des dépendances..."
	$(VENV_BIN)/pip-audit --format=json --output=dependencies_audit.json || true
	$(VENV_BIN)/pip-audit || true
	@echo "✅ Audit des dépendances terminé!"

# Nettoyage
clean:
	@echo "🧹 Nettoyage..."
	rm -rf __pycache__/
	rm -rf *.pyc
	rm -rf .pytest_cache/
	rm -rf build/
	rm -rf dist/
	rm -rf *.egg-info/
	rm -f test_*.txt test_*.qlk test_*.shares test_*_decrypted
	rm -f *.json.bak
	rm -f security_report.json dependencies_audit.json
	@echo "✅ Nettoyage terminé!"

# Nettoyage complet (inclut l'environnement virtuel)
distclean: clean
	rm -rf $(VENV)/
	@echo "🗑️  Nettoyage complet terminé!"

# Création d'un package de distribution
package:
	@echo "📦 Création du package de distribution..."
	@mkdir -p dist/quadlock-encrypt
	@cp quadlock_encrypt.py dist/quadlock-encrypt/
	@cp *.sh dist/quadlock-encrypt/
	@cp requirements.txt dist/quadlock-encrypt/
	@cp default_config.json dist/quadlock-encrypt/
	@cp README.md dist/quadlock-encrypt/ 2>/dev/null || echo "README.md non trouvé"
	@cp LICENSE dist/quadlock-encrypt/ 2>/dev/null || echo "LICENSE non trouvé"
	@cd dist && tar -czf quadlock-encrypt-$(shell date +%Y%m%d).tar.gz quadlock-encrypt/
	@echo "✅ Package créé: dist/quadlock-encrypt-$(shell date +%Y%m%d).tar.gz"

# Génération de la documentation
docs:
	@echo "📚 Génération de la documentation..."
	@$(PYTHON_VENV) -c "
import quadlock_encrypt
import inspect
import json

# Extraction automatique de la documentation des fonctions
app = quadlock_encrypt.QuadlockApp()
crypto = quadlock_encrypt.QuadlockCrypto()

doc = {
    'QuadlockApp': {
        'methods': [method for method in dir(app) if not method.startswith('_')],
        'docstring': app.__class__.__doc__
    },
    'QuadlockCrypto': {
        'methods': [method for method in dir(crypto) if not method.startswith('_')],
        'docstring': crypto.__class__.__doc__
    }
}

with open('api_documentation.json', 'w') as f:
    json.dump(doc, f, indent=2)
    
print('📄 Documentation API générée: api_documentation.json')
"

# Tests de performance
benchmark:
	@echo "⚡ Tests de performance..."
	@$(PYTHON_VENV) -c "
import time
import secrets
import os
from quadlock_encrypt import QuadlockApp

app = QuadlockApp()
sizes = [1024, 10240, 102400, 1048576]  # 1KB, 10KB, 100KB, 1MB

print('📊 Benchmarks de chiffrement:')
print('Taille\\t\\tChiffrement\\tDéchiffrement')
print('-' * 50)

for size in sizes:
    # Création du fichier de test
    data = secrets.token_bytes(size)
    filename = f'bench_{size}.bin'
    with open(filename, 'wb') as f:
        f.write(data)
    
    # Test de chiffrement
    start = time.time()
    app.encrypt_file(filename, 'benchpassword123')
    encrypt_time = time.time() - start
    
    # Test de déchiffrement
    with open(filename + '.shares', 'r') as f:
        lines = f.readlines()
    shares = [line.split(': ')[1].strip() for line in lines if line.startswith('Part')][:3]
    
    start = time.time()
    app.decrypt_file(filename + '.qlk', shares)
    decrypt_time = time.time() - start
    
    # Formatage de la taille
    if size < 1